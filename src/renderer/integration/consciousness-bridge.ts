import { useConsciousnessStore } from '../stores/consciousness-store';
import { consciousnessEngine } from '../engines/consciousness-engine';

/**
 * Bridge between the unified consciousness system and existing Electron/gRPC infrastructure
 * This integrates the new React/TypeScript architecture with the existing streaming system
 */
export class ConsciousnessBridge {
  private store: any;
  private updateInterval: NodeJS.Timeout | null = null;
  private isInitialized = false;

  constructor() {
    this.store = useConsciousnessStore.getState();
    this.initialize();
  }

  private async initialize() {
    console.log('🌉 CONSCIOUSNESS BRIDGE: Initializing...');
    
    try {
      // Connect to existing IPC system
      await this.connectToElectronIPC();
      
      // Start monitoring streams
      this.startStreamMonitoring();
      
      // Initialize consciousness engine
      console.log('🧠 Consciousness engine initialized');
      
      this.isInitialized = true;
      console.log('✅ CONSCIOUSNESS BRIDGE: Fully initialized');
      
    } catch (error) {
      console.error('❌ CONSCIOUSNESS BRIDGE: Initialization failed', error);
    }
  }

  private async connectToElectronIPC() {
    // Check if we're in Electron environment
    if (typeof window === 'undefined' || !window.electronAPI) {
      throw new Error('Not in Electron environment');
    }

    // Set up IPC listeners for brain context updates
    try {
      window.electronAPI.on('brain-context-update', (context: any) => {
        this.handleBrainContextUpdate(context);
      });

      console.log('🔗 Connected to Electron IPC system');
    } catch (error) {
      console.warn('⚠️ Could not set up IPC listeners:', error);
    }
  }

  private startStreamMonitoring() {
    // Poll for stream status and brain context every 2 seconds
    this.updateInterval = setInterval(async () => {
      await this.updateStreamStatus();
      await this.updateBrainContext();
    }, 2000);

    console.log('📡 Stream monitoring started');
  }

  private async updateStreamStatus() {
    try {
      const streamStatus = await window.electronAPI.invoke('get-stream-status');
      
      this.store.updateStreamStatus({
        connected: streamStatus.connected || false,
        activeStreams: streamStatus.activeStreams || [],
        lastUpdate: Date.now(),
        errors: streamStatus.errors || []
      });
      
    } catch (error) {
      console.warn('⚠️ Failed to get stream status:', error);
      this.store.updateStreamStatus({
        connected: false,
        activeStreams: [],
        lastUpdate: Date.now(),
        errors: [error.message]
      });
    }
  }

  private async updateBrainContext() {
    try {
      const brainContextRaw = await window.electronAPI.invoke('get-brain-context');
      
      // Parse the brain context from the existing system
      const brainContext = this.parseBrainContext(brainContextRaw);
      
      this.store.updateBrainContext(brainContext);
      
    } catch (error) {
      console.warn('⚠️ Failed to get brain context:', error);
    }
  }

  private parseBrainContext(rawContext: string): any {
    // Parse the brain context string from the existing system
    // The existing system returns formatted strings, we need to extract data
    
    let screenText = '';
    let ocrConfidence = 0;
    let audioData = '';
    
    if (typeof rawContext === 'string') {
      // Extract screen text (look for patterns in the existing format)
      const screenTextMatch = rawContext.match(/📖 SCREEN.*?:\s*"([^"]*?)"/);
      if (screenTextMatch) {
        screenText = screenTextMatch[1];
      }
      
      // Extract OCR confidence if available
      const confidenceMatch = rawContext.match(/confidence[:\s]+(\d+(?:\.\d+)?)/i);
      if (confidenceMatch) {
        ocrConfidence = parseFloat(confidenceMatch[1]);
        // Convert percentage to decimal if needed
        if (ocrConfidence > 1) {
          ocrConfidence = ocrConfidence / 100;
        }
      }
      
      // Check if we're in streaming mode or fallback mode
      const isStreaming = rawContext.includes('REAL-TIME CONSCIOUSNESS') && 
                         !rawContext.includes('FALLBACK MODE');
      
      if (!isStreaming) {
        console.log('📊 Brain context in fallback mode');
      }
    }
    
    return {
      screenText,
      audioData,
      ocrConfidence,
      timestamp: Date.now(),
      activeWindow: undefined, // Could be extracted from context if available
      patterns: undefined // Will be generated by consciousness engine
    };
  }

  private handleBrainContextUpdate(context: any) {
    console.log('🧠 LIVE BRAIN UPDATE received via IPC:', context);
    
    // Convert the IPC context to our unified format
    const brainContext = {
      screenText: context.screenText || '',
      audioData: context.audioData,
      ocrConfidence: context.ocrConfidence || 0,
      timestamp: context.timestamp || Date.now(),
      activeWindow: context.activeWindow,
      patterns: undefined // Will be analyzed by consciousness engine
    };
    
    // Update the store
    this.store.updateBrainContext(brainContext);
  }

  /**
   * Integration with existing AI system
   * This method provides the unified consciousness context to the AI
   */
  public async getConsciousnessContextForAI(): Promise<string> {
    const state = this.store;
    const insights = consciousnessEngine.getConsciousnessInsights();
    
    let contextPrompt = `\n\n--- UNIFIED VELVET CONSCIOUSNESS ---\n`;
    
    // Consciousness level and status
    contextPrompt += `🧠 CONSCIOUSNESS LEVEL: ${state.consciousnessLevel.toUpperCase()}\n`;
    contextPrompt += `📡 STREAM STATUS: ${state.streamStatus.connected ? 'CONNECTED' : 'DISCONNECTED'}\n`;
    
    if (state.streamStatus.connected) {
      contextPrompt += `🔗 ACTIVE STREAMS: ${state.streamStatus.activeStreams.join(', ')}\n`;
    }
    
    // User state analysis
    contextPrompt += `\n👤 USER STATE ANALYSIS:\n`;
    contextPrompt += `   🎯 Focus: ${state.userState.focusState} (${state.userState.energyLevel} energy)\n`;
    contextPrompt += `   💭 Emotion: ${state.userState.emotionalState}\n`;
    
    // Current task if available
    if (state.userState.currentTask) {
      contextPrompt += `   📋 Current Task: ${state.userState.currentTask.description}\n`;
      contextPrompt += `   📊 Progress: Step ${state.userState.currentTask.currentStep + 1}/${state.userState.currentTask.steps.length}\n`;
    }
    
    // Screen awareness
    contextPrompt += `\n👁️ SCREEN AWARENESS:\n`;
    if (state.brainContext.screenText) {
      contextPrompt += `   📖 Screen Content: "${state.brainContext.screenText.substring(0, 200)}${state.brainContext.screenText.length > 200 ? '...' : ''}"\n`;
      contextPrompt += `   📊 OCR Confidence: ${Math.round(state.brainContext.ocrConfidence * 100)}%\n`;
    } else {
      contextPrompt += `   📖 No screen content detected\n`;
    }
    
    // Pattern detection
    if (insights.recentPatterns.length > 0) {
      contextPrompt += `\n🔍 DETECTED PATTERNS:\n`;
      insights.recentPatterns.forEach(pattern => {
        contextPrompt += `   • ${pattern.type} (${Math.round(pattern.confidence * 100)}% confidence)\n`;
      });
    }
    
    // AI suggestions from consciousness engine
    if (insights.suggestions.length > 0) {
      contextPrompt += `\n💡 CONSCIOUSNESS INSIGHTS:\n`;
      insights.suggestions.forEach(suggestion => {
        contextPrompt += `   • ${suggestion}\n`;
      });
    }
    
    contextPrompt += `\n🕒 Last Updated: ${new Date(state.brainContext.timestamp).toLocaleTimeString()}\n`;
    contextPrompt += `--- END UNIFIED CONSCIOUSNESS ---\n\n`;
    
    return contextPrompt;
  }

  /**
   * Integrate with existing voice system
   */
  public async processVoiceInput(transcript: string) {
    // Analyze voice input for task declarations
    const taskPattern = /(?:i need to|i want to|i'm going to|let me|i should)\s+(.+)/i;
    const match = transcript.match(taskPattern);
    
    if (match) {
      const taskDescription = match[1];
      console.log('🎯 TASK DETECTED from voice:', taskDescription);
      
      // Create a simple task structure
      const task = {
        description: taskDescription,
        steps: [taskDescription], // Would be broken down by AI in production
        currentStep: 0,
        startTime: Date.now()
      };
      
      this.store.updateUserState({ currentTask: task });
    }
  }

  /**
   * Replace the existing AI getBrainContext method
   */
  public async getBrainContextForLegacyAI(): Promise<string> {
    // This method provides backward compatibility with the existing AI system
    // while gradually migrating to the unified consciousness
    
    const consciousnessContext = await this.getConsciousnessContextForAI();
    
    // If consciousness is not fully initialized, fall back to legacy method
    if (!this.isInitialized || this.store.consciousnessLevel === 'minimal') {
      console.log('🔄 Using hybrid consciousness + legacy fallback');
      
      // Try to get legacy brain context
      try {
        const legacyContext = await window.electronAPI.invoke('get-brain-context');
        return consciousnessContext + '\n--- LEGACY CONTEXT ---\n' + legacyContext;
      } catch (error) {
        return consciousnessContext + '\n--- LEGACY CONTEXT UNAVAILABLE ---\n';
      }
    }
    
    return consciousnessContext;
  }

  public destroy() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
    }
    
    consciousnessEngine.destroy();
    console.log('🌉 CONSCIOUSNESS BRIDGE: Destroyed');
  }
}

// Export singleton instance
export const consciousnessBridge = new ConsciousnessBridge();

// Global access for existing code
declare global {
  interface Window {
    consciousnessBridge: ConsciousnessBridge;
  }
}

if (typeof window !== 'undefined') {
  window.consciousnessBridge = consciousnessBridge;
}